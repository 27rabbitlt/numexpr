#!/usr/bin/env python
###################################################################
#  NumExpr - Fast numerical array expression evaluator for NumPy.
#
#      License: MIT
#      Author:  See AUTHORS.txt
#
#  See LICENSE.txt and LICENSES/*.txt for details about copyright and
#  rights to use.
####################################################################

import sys, os, os.path as op, io
# import setuptools
from setuptools import setup, find_packages, Extension
# from setuptools.command.build_ext import build_ext
import platform
import numpy as np

if sys.version_info < (3, 6):
    raise RuntimeError("NumExpr requires Python 3.6 or greater")

with open('requirements.txt') as f:
    requirements = f.read().splitlines()

with io.open('README.rst', encoding='utf-8') as f:
    LONG_DESCRIPTION = f.read()

major_ver = 2
minor_ver = 8
nano_ver = 0
branch = 'dev0'

version = '%d.%d.%d%s' % (major_ver, minor_ver, nano_ver, branch)
with open('numexpr/version.py', 'w') as fh:
    fh.write('# THIS FILE IS GENERATED BY `SETUP.PY`\n')
    fh.write("version = '%s'\n" % version)
    try:
        import numpy
        fh.write("numpy_build_version = '%s'\n" % numpy.__version__)
    except ImportError:
        pass
    
lib_dirs = []
inc_dirs = [np.get_include(), op.join('framestream')]
libs = []  # Pre-built libraries ONLY, like python36.so
clibs = []
def_macros = []
sources = ['numexpr/interpreter.cpp',
           'numexpr/module.cpp',
           'numexpr/numexpr_object.cpp']
extra_cflags = []
extra_link_args = []

if platform.uname().system == 'Windows':
    extra_cflags = ['/O2']
    extra_link_args = []
    sources.append('numexpr/win32/pthread.c')
else:
    extra_cflags = []
    extra_link_args = []

numexpr_extension = Extension('numexpr.interpreter',
    include_dirs=inc_dirs,
    define_macros=def_macros,
    sources=sources,
    library_dirs=lib_dirs,
    libraries=libs,
    extra_compile_args=extra_cflags,
    extra_link_args=extra_link_args,)

def setup_package():
    metadata = dict(
                    name = 'numexpr',
                    version = version,
                    description = 'Fast numerical expression evaluator for NumPy',
                    author = 'David M. Cooke, Francesc Alted, and others',
                    author_email = 'david.m.cooke@gmail.com, faltet@gmail.com',
                    maintainer = 'Robert A. McLeod',
                    maintainer_email = 'robbmcleod@gmail.com',
                    url = 'https://github.com/pydata/numexpr',
                    long_description = LONG_DESCRIPTION,
                    license = 'MIT',
                    packages = find_packages(),
                    install_requires = requirements,
                    setup_requires = requirements,
                    extras_require = {
                        },
                    libraries = clibs,
                    ext_modules = [
                            numexpr_extension
                        ],
                    zip_safe = False,
                    classifiers = [
                            'Development Status :: 6 - Mature',

                            'Intended Audience :: Financial and Insurance Industry',
                            'Intended Audience :: Science/Research',

                            'License :: OSI Approved :: MIT License',
                    
                            'Programming Language :: Python :: 3',
                            'Programming Language :: Python :: 3.6',
							'Programming Language :: Python :: 3.7',
                            'Programming Language :: Python :: 3.8',
                            'Programming Language :: Python :: 3.9',
                            'Programming Language :: Python :: 3.10',
                            # OS
                            'Operating System :: Microsoft :: Windows',
                            'Operating System :: POSIX',
                            'Operating System :: MacOS',
                        ],
                    
    )
    
    # def configuration():
    #     from numpy.distutils.misc_util import Configuration, dict_append
    #     from numpy.distutils.system_info import system_info

    #     config = Configuration('numexpr')

    #     #try to find configuration for MKL, either from environment or site.cfg
    #     if op.exists('site.cfg'):
    #         mkl_config_data = config.get_info('mkl')
    #         # Some version of MKL needs to be linked with libgfortran.
    #         # For this, use entries of DEFAULT section in site.cfg.
    #         default_config = system_info()
    #         dict_append(mkl_config_data,
    #                     libraries=default_config.get_libraries(),
    #                     library_dirs=default_config.get_lib_dirs())
    #     else:
    #         mkl_config_data = {}

    #     # setup information for C extension
    #     if os.name == 'nt':
    #         pthread_win = ['numexpr/win32/pthread.c']
    #     else:
    #         pthread_win = []
    #     extension_config_data = {
    #         'sources': ['numexpr/interpreter.cpp',
    #                     'numexpr/module.cpp',
    #                     'numexpr/numexpr_object.cpp'] + pthread_win,
    #         'depends': ['numexpr/interp_body.cpp',
    #                     'numexpr/complex_functions.hpp',
    #                     'numexpr/interpreter.hpp',
    #                     'numexpr/module.hpp',
    #                     'numexpr/msvc_function_stubs.hpp',
    #                     'numexpr/numexpr_config.hpp',
    #                     'numexpr/numexpr_object.hpp'],
    #         'libraries': ['m'],
    #         'extra_compile_args': ['-funroll-all-loops', ],
    #     }
    #     dict_append(extension_config_data, **mkl_config_data)
    #     if 'library_dirs' in mkl_config_data:
    #         library_dirs = ':'.join(mkl_config_data['library_dirs'])
    #     config.add_extension('interpreter', **extension_config_data)
    #     config.set_options(quiet=True)

    #     config.make_config_py()
    #     config.add_subpackage('tests', 'numexpr/tests')

    #     #version handling
    #     config.get_version('numexpr/version.py')
    #     return config


    # class cleaner(setuptools.command.clean):
    #
    #     def run(self):
    #         # Recursive deletion of build/ directory
    #         path = localpath("build")
    #         try:
    #             shutil.rmtree(path)
    #         except Exception:
    #             debug("Failed to remove directory %s" % path)
    #         else:
    #             debug("Cleaned up %s" % path)
    #
    #         # Now, the extension and other files
    #         try:
    #             import imp
    #         except ImportError:
    #             if os.name == 'posix':
    #                 paths = [localpath("numexpr/interpreter.so")]
    #             else:
    #                 paths = [localpath("numexpr/interpreter.pyd")]
    #         else:
    #             paths = []
    #             for suffix, _, _ in imp.get_suffixes():
    #                 if suffix == '.py':
    #                     continue
    #                 paths.append(localpath("numexpr", "interpreter" + suffix))
    #         paths.append(localpath("numexpr/__config__.py"))
    #         paths.append(localpath("numexpr/__config__.pyc"))
    #         for path in paths:
    #             try:
    #                 os.remove(path)
    #             except Exception:
    #                 debug("Failed to clean up file %s" % path)
    #             else:
    #                 debug("Cleaning up %s" % path)
    #
    #         setuptools.clean.run(self)

    # class build_ext(numpy_build_ext):
    #     def build_extension(self, ext):
    #         # at this point we know what the C compiler is.
    #         if self.compiler.compiler_type == 'msvc' or self.compiler.compiler_type == 'intelemw':
    #             ext.extra_compile_args = []
    #             # also remove extra linker arguments msvc doesn't understand
    #             ext.extra_link_args = []
    #             # also remove gcc math library
    #             ext.libraries.remove('m')
    #         numpy_build_ext.build_extension(self, ext)

   
        # metadata['cmdclass'] = {
        #     'build_ext': build_ext,
        #     # 'clean': cleaner,
        #     'build_py': build_py,
        # }
        # metadata['configuration'] = configuration

    setup(**metadata)


if __name__ == '__main__':
    setup_package()
